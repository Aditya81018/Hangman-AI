import { cn } from "@/lib/utils";
import Keyboard from "./keyboard";
import { useEffect, useState, useCallback } from "react";
import Hangman, { type Parts } from "./hangman";
import { ModeToggle } from "@/components/mode-toggle";
import { Button } from "@/components/ui/button";
// import { getRandom } from "@/lib/helper";
// import words from "@/data/words.json"; // REMOVE STATIC WORDS IMPORT
import { ArrowLeft } from "lucide-react";
import { Link, useParams } from "react-router-dom";
import { generateHangmanWords } from "@/services/genai";

// Define the type for the AI-generated word object
interface HangmanWordObject {
  category: string;
  word: string;
  hint: string;
}

export default function GamePage() {
  const parts: Parts[] = [
    "rope",
    "face",
    "body",
    "left-arm",
    "right-arm",
    "left-leg",
    "right-leg",
  ];
  const { difficulty } = useParams();

  const [wordBatch, setWordBatch] = useState<HangmanWordObject[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  const [category, setCategory] = useState("");
  const [originalWord, setOriginalWord] = useState("");
  const [decodedWord, setDecodedWord] = useState("");
  const [disabledKeys, setDisabledKeys] = useState("");
  const [lives, setLives] = useState(parts.length);
  const [hiddenParts, setHiddenParts] = useState<Parts[]>(parts);
  const [gameState, setGameState] = useState<
    "playing" | "won" | "lost" | "waiting"
  >("waiting");
  const [hint, setHint] = useState("");
  const [level, setLevel] = useState(1);

  /**
   * Function to call the AI for a new batch of words.
   * Uses useCallback to prevent unnecessary re-creation.
   */
  const fetchNewWordBatch = useCallback(async () => {
    if (wordBatch.length === 0) setIsLoading(true);
    console.log(`Fetching new batch`);
    try {
      const newWords = await generateHangmanWords(
        `Set of completely random words for hangman, the difficulty is ${difficulty}`,
        wordBatch.map((e) => e.word)
      );
      setWordBatch((words) => [...words, ...newWords]);
    } catch (error) {
      console.error("Failed to generate words:", error);
      // Fallback: Set a single, simple word if API fails
      setWordBatch((words) => [
        ...words,
        { category: "Fallback", word: "CODE", hint: "It runs everything." },
      ]);
    } finally {
      setIsLoading(false);
    }
  }, [wordBatch.length]); // instructions is a dependency

  // --- PRIMARY EFFECT: Load the initial word batch ---
  useEffect(() => {
    console.log(level, wordBatch.length);
    if (
      (level === 1 && wordBatch.length === 0) ||
      level === wordBatch.length - 3
    )
      fetchNewWordBatch();
  }, [level, wordBatch]);

  // --- SECONDARY EFFECT: Set the game word when the batch/index changes ---
  useEffect(() => {
    if (
      wordBatch.length > 0 &&
      level < wordBatch.length &&
      gameState === "waiting"
    ) {
      const {
        category: newCategory,
        word: newWord,
        hint: newHint,
      } = wordBatch[level - 1];

      // Update all word-related state
      setCategory(newCategory);
      setOriginalWord(newWord.toUpperCase());
      setHint(newHint); // The hint is already generated by generateHangmanWords
      setDisabledKeys("");
      setLives(parts.length);
      setGameState("playing");

      // Reset the decoded word
      setDecodedWord(
        newWord
          .toUpperCase()
          .split("")
          .map((letter: string) => (letter === " " ? " " : "_"))
          .join("")
      );

      console.log(newWord);
      console.log(wordBatch);
    }
  }, [wordBatch, level, gameState]);

  useEffect(() => {
    setHiddenParts(parts.slice(parts.length - lives, parts.length));
    if (lives === 0) {
      setGameState("lost");
    }
  }, [lives]);

  /**
   * Handles a key click event.
   * ... (Rest of the logic remains the same)
   */
  function handleKeyClick(key: string) {
    setDisabledKeys((prev) => prev + key);
    setDecodedWord((prev) => {
      const newWord = prev.split("");
      let isUpdated = false;
      for (let i = 0; i < originalWord.length; i++) {
        if (originalWord[i] === key) {
          newWord[i] = key;
          isUpdated = true;
        }
      }

      if (!isUpdated) {
        setLives((prev) => prev - 1);
      }

      if (newWord.join("") === originalWord) {
        setGameState("won");
      }

      return newWord.join("");
    });
  }

  /**
   * Handles the restart button click event.
   * Moves to the next word or fetches a new batch if needed.
   */
  function handleRestart() {
    setGameState("waiting");

    if (gameState === "lost") {
      setLevel(1);
      // If lost, just go to the next word in the current batch or restart the batch
      setLevel(1);
      setWordBatch([]);
      fetchNewWordBatch();
      return;
    }

    // WIN CONDITION LOGIC: Check for the 9, 19, 29, etc. threshold
    setLevel((currentLevel) => currentLevel + 1);
  }

  /**
   * Component that displays the decoded word.
   * ... (This remains the same)
   */
  function Output() {
    return (
      <div className="flex gap-1">
        {decodedWord.split("").map((letter, i) => (
          <div
            key={i}
            className={cn(
              "flex border-b-2 font-mono px-2 pb-2 items-center justify-center w-4 h-4",
              letter === " " && "invisible"
            )}
          >
            {letter !== "_" && letter}
          </div>
        ))}
      </div>
    );
  }

  if (isLoading || originalWord === "") {
    return (
      <div className="w-screen h-screen flex flex-col justify-center items-center">
        <div className="text-xl font-bold">
          Generating a fresh batch of words...
        </div>
        <div className="text-sm text-muted">This may take a moment.</div>
      </div>
    );
  }

  return (
    <>
      <Link to="/" className="absolute top-4 left-4">
        <Button variant={"ghost"} size={"icon"}>
          <ArrowLeft />
        </Button>
      </Link>
      <div className="w-screen h-screen px-8 flex flex-col justify-center items-center gap-8">
        <div className="font-bold text-2xl text-center">Level {level}</div>
        <Hangman hiddenParts={hiddenParts} />
        <div className="capitalize text-2xl font-bold">
          {category.replaceAll("_", " ")}
        </div>
        <div className="text-sm text-muted font-mono -mt-6 text-center">
          {hint}
        </div>
        <Output />
        {gameState === "playing" ? (
          <Keyboard disabledKeys={disabledKeys} onClick={handleKeyClick} />
        ) : gameState === "won" ? (
          <div className="flex flex-col gap-4 items-center justify-center">
            <div className="text-4xl font-bold uppercase">YOU WON ðŸŽ‰</div>
            <Button onClick={handleRestart}>Next Word</Button>
          </div>
        ) : (
          <div className="flex flex-col gap-4 items-center justify-center">
            <div className="text-4xl font-bold uppercase">GAME OVER ðŸ’€</div>
            <div>
              The word was: <span className="font-bold">{originalWord}</span>
            </div>
            <Button onClick={handleRestart}>Restart</Button>
          </div>
        )}
        <ModeToggle />
      </div>
    </>
  );
}
