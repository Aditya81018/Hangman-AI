import { cn } from "@/lib/utils";
import Keyboard from "./keyboard";
import { useEffect, useState, useCallback } from "react";
import Hangman, { type Parts } from "./hangman";
import { ModeToggle } from "@/components/mode-toggle";
import { Button } from "@/components/ui/button";
// import { getRandom } from "@/lib/helper";
// import words from "@/data/words.json"; // REMOVE STATIC WORDS IMPORT
import { ArrowLeft, Loader2 } from "lucide-react";
import { Link, useParams, useSearchParams } from "react-router-dom";
import { generateHangmanWords } from "@/services/genai";

// Define the type for the AI-generated word object
interface HangmanWordObject {
  category: string;
  word: string;
  hint: string;
}

export default function GamePage() {
  const parts: Parts[] = [
    "rope",
    "face",
    "body",
    "left-arm",
    "right-arm",
    "left-leg",
    "right-leg",
  ];
  const { difficulty = "medium" } = useParams();
  const [searchParams] = useSearchParams();
  const instructions = searchParams.get("instructions");

  const [wordBatch, setWordBatch] = useState<HangmanWordObject[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  const [category, setCategory] = useState("");
  const [originalWord, setOriginalWord] = useState("");
  const [decodedWord, setDecodedWord] = useState("");
  const [disabledKeys, setDisabledKeys] = useState("");
  const [lives, setLives] = useState(parts.length);
  const [hiddenParts, setHiddenParts] = useState<Parts[]>(parts);
  const [gameState, setGameState] = useState<
    "playing" | "won" | "lost" | "waiting"
  >("waiting");
  const [hint, setHint] = useState("");
  const [level, setLevel] = useState(1);

  /**
   * Function to call the AI for a new batch of words.
   * Uses useCallback to prevent unnecessary re-creation.
   */
  const fetchNewWordBatch = useCallback(async () => {
    if (wordBatch.length === 0) setIsLoading(true);
    console.log(`Fetching new batch`);
    try {
      const newWords = await generateHangmanWords(
        `Set of unique and random words for hangman, the difficulty is ${difficulty}. ${instructions}`,
        wordBatch.map((e) => e.word)
      );
      setWordBatch((words) => [...words, ...newWords]);
    } catch (error) {
      console.error("Failed to generate words:", error);
      // Fallback: Set a single, simple word if API fails
      setWordBatch((words) => [
        ...words,
        { category: "Fallback", word: "CODE", hint: "It runs everything." },
      ]);
    } finally {
      setIsLoading(false);
    }
  }, [wordBatch.length]); // instructions is a dependency

  // --- PRIMARY EFFECT: Load the initial word batch ---
  useEffect(() => {
    console.log(level, wordBatch.length);
    if (
      (level === 1 && wordBatch.length === 0) ||
      level === wordBatch.length - 3
    )
      fetchNewWordBatch();
  }, [level, wordBatch]);

  // --- SECONDARY EFFECT: Set the game word when the batch/index changes ---
  useEffect(() => {
    if (
      wordBatch.length > 0 &&
      level < wordBatch.length &&
      gameState === "waiting"
    ) {
      const {
        category: newCategory,
        word: newWord,
        hint: newHint,
      } = wordBatch[level - 1];

      console.log("ran");

      // Update all word-related state
      setCategory(newCategory);
      setOriginalWord(newWord.toUpperCase());
      setHint(newHint); // The hint is already generated by generateHangmanWords
      setDisabledKeys("");
      setLives(parts.length);
      setGameState("playing");

      // Reset the decoded word
      setDecodedWord(
        newWord
          .toUpperCase()
          .split("")
          .map((letter: string) => (letter === " " ? " " : "_"))
          .join("")
      );

      console.log(newWord);
      console.log(wordBatch);
    }
  }, [wordBatch, level, gameState]);

  useEffect(() => {
    setHiddenParts(parts.slice(parts.length - lives, parts.length));
    if (lives === 0) {
      setGameState("lost");
    }
  }, [lives]);

  /**
   * Handles a key click event.
   * ... (Rest of the logic remains the same)
   */
  function handleKeyClick(key: string) {
    setDisabledKeys((prev) => prev + key);
    setDecodedWord((prev) => {
      const newWord = prev.split("");
      let isUpdated = false;
      for (let i = 0; i < originalWord.length; i++) {
        if (originalWord[i] === key) {
          newWord[i] = key;
          isUpdated = true;
        }
      }

      if (!isUpdated) {
        setLives((prev) => prev - 1);
      }

      if (newWord.join("") === originalWord) {
        setGameState("won");
      }

      return newWord.join("");
    });
  }

  /**
   * Handles the restart button click event.
   * Moves to the next word or fetches a new batch if needed.
   */
  function handleRestart() {
    setGameState("waiting");

    if (gameState === "lost") {
      setLevel(1);
      // If lost, just go to the next word in the current batch or restart the batch
      setLevel(1);
      setWordBatch([]);
      fetchNewWordBatch();
      return;
    }

    // WIN CONDITION LOGIC: Check for the 9, 19, 29, etc. threshold
    setLevel((currentLevel) => currentLevel + 1);
  }

  /**
   * Component that displays the decoded word.
   * ... (This remains the same)
   */
  function Output() {
    // 1. Split the original word by space to get individual words/segments.
    const wordSegments = originalWord.split(" ");

    // 2. Split the decoded word by space to map letters correctly.
    const decodedSegments = decodedWord.split(" ");

    return (
      // Use 'flex flex-wrap' on the outer container to allow the segments to wrap
      <div className="flex flex-wrap justify-center gap-x-4 gap-y-4">
        {wordSegments.map((_originalSegment, segmentIndex) => {
          // Get the corresponding decoded segment
          const decodedSegment = decodedSegments[segmentIndex] || "";

          return (
            // This div represents one entire word/segment and allows it to wrap to the next line
            // if the previous segments don't fit. We don't need 'flex-wrap' here,
            // just the individual letters.
            <div key={`segment-${segmentIndex}`} className="flex gap-1">
              {decodedSegment.split("").map((letter, letterIndex) => (
                <div
                  key={`segment-${segmentIndex}-letter-${letterIndex}`}
                  className={cn(
                    // Removed fixed w-4/h-4 if it was causing overflow, relying on padding/border
                    "flex border-b-2 font-mono px-2 items-center justify-center w-6 h-6 text-xl"
                  )}
                >
                  {letter !== "_" && letter}
                </div>
              ))}
            </div>
          );
        })}
      </div>
    );
  }

  if (isLoading || originalWord === "") {
    return (
      <div className="w-screen h-screen flex flex-col justify-center items-center">
        <Loader2 className="animate-spin mb-8" />
        <div className="text-xl font-bold">
          Generating a fresh batch of words...
        </div>
        <div className="text-sm text-muted">This may take a moment.</div>
        <ModeToggle />
      </div>
    );
  }

  return (
    <>
      <Link to="/" className="absolute top-4 left-4">
        <Button variant={"ghost"} size={"icon"}>
          <ArrowLeft />
        </Button>
      </Link>
      <div className="w-screen h-screen px-8 flex flex-col justify-evenly items-center gap-8">
        <div className="font-bold text-2xl text-center">Level {level}</div>
        <div className="flex gap-8 items-center justify-evenly lg:flex-row-reverse flex-col w-full">
          <Hangman hiddenParts={hiddenParts} />
          <div className="flex flex-col gap-8 items-center lg:w-md">
            <div className="capitalize text-2xl font-bold">
              {category.replaceAll("_", " ")}
            </div>
            <div className="text-sm text-muted font-mono -mt-6 text-center">
              {hint}
            </div>
            <Output />
            {gameState === "playing" || gameState === "waiting" ? (
              <Keyboard disabledKeys={disabledKeys} onClick={handleKeyClick} />
            ) : gameState === "won" ? (
              <div className="flex flex-col gap-4 items-center justify-center">
                <div className="text-4xl font-bold uppercase">YOU WON ðŸŽ‰</div>
                <Button onClick={handleRestart}>Next Word</Button>
              </div>
            ) : (
              gameState === "lost" && (
                <div className="flex flex-col gap-4 items-center justify-center">
                  <div className="text-4xl font-bold uppercase">
                    GAME OVER ðŸ’€
                  </div>
                  <div>
                    The word was:{" "}
                    <span className="font-bold">{originalWord}</span>
                  </div>
                  <Button onClick={handleRestart}>Restart</Button>
                </div>
              )
            )}
          </div>
        </div>
        <ModeToggle />
      </div>
    </>
  );
}
